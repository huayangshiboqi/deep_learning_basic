测试样例说明：

建议使用ultra edit等工具打开数据文件

1、输入数据+参数+偏置.txt

存放输入数据，数据16进制表示，有符号数。每个数据8bit（即两个字符），每一行表示64个输入通道的数据。

ifm表示输入的feature map数据，32*32*64，数据按照x方向后y方向连续存放，每一行表示64个输入通道的数据。

weights表示参数数据，3*3*64 128个，每一行表示64个输入通道对应相乘的weights的数据，每组64行表示64个输出通道对应的weights数据。
接着连续9组，表示3*3 kernel大小的weights，kernel按照先x方向后y方向摆放。之后按照相同的方式摆放后64个输出通道对应的weights数据。
换句话说，前64个kernels放在一起，后64个kernels放在一起。前64个kernels，按照每个kernel的对应位置放在一起的规则存储

const表示偏置数据。每个bias数据16bit，每个输出通道对应一个偏置数据。

2、输出前64个通道数据.txt & 输出后64个通道数据.txt

存放输出feature map的数据，有符号数。每个数据8bit（即两个字符），每一行表示64个输出通道的数据。
两个文件分别存放了输出数据的前64个通道数据和后64个通道的数据。

计算的结果是经过数据截位变成8bit数据的。截位方式为扔掉结果数据的低4bit并进行四舍五入。再截去高位，截成8bit，并进行饱和操作。




